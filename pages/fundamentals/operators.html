
<h1>Common Operators</h1>

<p>
Operator operations are the operations using all kinds of operators.
This article will introduce common operators in Go.
More operators will be introduced in other articles later.
</p>

<h3>About Some Descriptions in Operator Explanations</h3>

<p>
This article will only introduce arithmetic operators, bitwise operators,
comparison operators, boolean operators and string concatenation operator.
These operators are either binary operators or unary operators.
A binary operator operation takes two operands and
a unary operator operation takes only one operand.
</p>

<p>
All the operator operations introduced in this article each returns one result.
</p>

<div>

<p>This article doesn't pursue the accuracy of some descriptions.
For example, when it says that a binary operator requires
the types of its two operands must be the same,
what it means is:</p>
<ul>
<li>
	if both of the two operands are typed values,
	then their types must be the same one,
	or one operand can be implicitly converted to the type of the other.
</li>
<li>
	if only one of the two operands is typed,
	then the other (untyped) operand must be representable as
	a value of the type of the typed operand,
	or the values of the default type of the other (untyped) operand
	can be implicitly converted to the typed of the typed operand.
</li>
<li>
	if both operands are untyped values,
	then they must be both boolean values,
	both string values or both basic numeric values.
</li>
</ul>

<p>Similarly, when it says an operator,
either a binary operator or a unary operator,
requires the type of one of its operands to be of a certain type,
what it means is:</p>
<ul>
<li>
	if the operand is typed, then its type must be,
	or can be implicitly converted to, that certain type.
</li>
<li>
	if the operand is untyped, then the untyped value must be
	representable as a value of that certain type,
	or the values of the default type of the operand
	can be implicitly converted to that certain type.
</li>
</ul>

<p>
</p>

</div>

<a class="anchor" id="constant-expression"></a>
<h3>Constant Expressions</h3>

<p>
Before introducing all kinds of operators,
we should know what are constant expressions
and a fact in the evaluations of constant expressions.
Expressions will get explained in a later article
<a href="expressions-and-statements.html">expressions and statements</a>.
At present, we just should know that most of the operations mentioned
the current article are expressions.
</p>

<p>
If all the operands involved in an expression are constants,
then this expression is called a constant expression.
All constant expressions are evaluated at compile time.
The evaluation result of a constant expression is still a constant.
</p>

<p>
Only if one operand in an expression is not a constant,
the expression is called a non-constant expression.
</p>

<h3>Arithmetic Operators</h3>

<div>
<p>
Go supports five basic binary arithmetic operators:
</p>

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Requirements for the Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			addition
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4" valign="middle" align="left">
			The two operands must be both values of the same basic numeric type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			subtraction
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">*</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			multiplication
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">/</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			division
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">%</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			remainder
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			The two operands must be both values of the same basic integer type.
		</td>
	</tr>
</tbody>
</table>

<p>
The five operators are also often called <b>sum</b>, <b>difference</b>,
<b>product</b>, <b>quotient</b> and <b>modulo</b> operators, respectively.
Go 101 will not explain how these operator operations work in detail.
</p>

<p>
Go supports six bitwise binary arithmetic operators:
</p>

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Requirements for the Two Operands and Mechanism Explanations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>&amp;<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise and
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4" valign="middle" align="left">
			<p>
			The two operands must be both values of the same integer type.
			</p>

			Mechanism explanations (a value with the subscript <code>2</code> is the binary literal form of the value):
			<ul>
			<li>
				<code>1100<sub>2</sub> &amp; 1010<sub>2</sub></code>
				results in <code>1000<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> | 1010<sub>2</sub></code>
				results in <code>1110<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> ^ 1010<sub>2</sub></code>
				results in <code>0110<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> &amp;^ 1010<sub>2</sub></code>
				results in <code>0100<sub>2</sub></code>
			</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>|<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise or
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>^<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise xor
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>&amp;^<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise clear
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><br/><br/>&lt;&lt;<br/><br/><br/></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise left shift
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2" valign="middle" align="left">
			<p>
			The left operand must be an integer
			and the right operand must be also an integer (if it is a constant, then it must be non-negative),
			their types are not required to be identical.
			(Note, before Go 1.13, the right operand must be an unsigned integer or
			an <a href="constants-and-variables.html#untyped-value">untyped</a>
			integer constant which is representable as an <code>uint</code> value.)
			</p>

			<p>
			A negative right operand (must be a non-constant) will cause a panic at run time.
			</p>

			Mechanism explanations:
			<ul>
			<li>
				<code>1100<sub>2</sub> &lt;&lt; 3</code>
				results in <code>1100000<sub>2</sub></code>
			</li>
			<li>
				<code>1100<sub>2</sub> &gt;&gt; 3</code>
				results in <code>1<sub>2</sub></code>
			</li>
			</ul>

			<p>
			Note: in a bitwise-right-shift operation, all the freed-up bits
			at left are filled with the sign bit (the highest bit) of the left operand.
			For example. if the left operand is an <code>int8</code> value <code>-128</code>,
			or <code>10000000<sub>2</sub></code> in the binary literal form,
			then <code>10000000<sub>2</sub> &gt;&gt; 2</code> results
			<code>11100000<sub>2</sub></code>, a.k.a., <code>-32</code>.
			</p>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><br/><br/>&gt;&gt;<br/><br/><br/></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise right shift
		</td>
	</tr>
</tbody>
</table>

<p>
Go also supports three unary arithmetic operators:
</p>

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Explanations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			positive
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			<code>+n</code> is equivalent to <code>0 + n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			negative
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			<code>-n</code> is equivalent to <code>0 - n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			bitwise complement<br/>
			(bitwise not)
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			<code>^n</code> is equivalent to <code>m ^ n</code>,
			where <code>m</code> is a value all of which bits are 1.
			For example,
			if the type of <code>n</code> is <code>int8</code>,
			then <code>m</code> is <code>-1</code>,
			and if the type of <code>n</code> is <code>uint8</code>,
			then <code>m</code> is <code>0xFF</code>.
		</td>
	</tr>
</tbody>
</table>

Note,
<ul>
<li>
	in many other languages,
	bitwise-complement operator is denoted as <code>~</code>.
</li>
<li>
	like many other languages,
	the addition binary operator <code>+</code> can also be used as <b>string concatenation</b> operator,
	which will be introduced below.
</li>
<li>
	like C and C++ languages,
	the multiplication binary operator <code>*</code> can also be used as <b>pointer dereference</b> operator,
	and the bitwise-and operator <code>&amp;</code> can also be used as <b>pointer address</b> operator.
	Please read <a href="pointer.html">pointers in Go</a> for details later.
</li>
<li>
	unlike Java language, Go supports unsigned integer types,
	so the unsigned shift operator <code>&gt;&gt;&gt;</code> doesn't exist in Go.
</li>
<li>
	there is no power operator in Go, please use <code>Pow</code> function
	in the <code>math</code> standard package instead.
	Code package and package import will be introduced in the next article
	<a href="packages-and-imports.html">packages and imports</a>.
</li>
<li>
	the bitwise-clear operator <code>&amp;^</code> is a unique operator in Go.
	<code>m &amp;^ n</code> is equivalent to <code>m &amp; (^n)</code>.
</li>
</ul>

<p>
</p>

Example:
<pre class="line-numbers"><code class="language-go">func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// The ones compile okay.
	_ = 12 + 'A' // two numeric untyped operands
	_ = 12 - a   // one untyped and one typed operand
	_ = a * b    // two typed operands
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// The following ones fail to compile.
	_ = a % b   // error: a and b are not integers
	_ = a | b   // error: a and b are not integers
	_ = c + e   // error: type mismatching
	_ = b >> 5  // error: b is not an integer
	_ = c >> -5 // error: -5 is not representable as uint

	_ = e << uint(c) // compiles ok
	_ = e << c       // only compiles ok since Go 1.13
	_ = e << -c      // only compiles ok since Go 1.13,
	                 // will cause a panic at run time.
	_ = e << -1      // error: right operand is negative
}
</code></pre>

<p>
</p>

</div>

<h4>About overflows</h4>

<div>

<p>
Overflows are not allowed for typed constant values
but are allowed for non-constant and untyped constant values,
either the values are intermediate or final results.
Overflows will be truncated (or wrapped around) for non-constant values,
but overflows (for default types) on untyped constant value
will not be truncated (or wrapped around).
</p>

Example:
<pre class="line-numbers"><code class="language-go">// Results are non-constants.
var a, b uint8 = 255, 1
// Compiles ok, higher overflowed bits are truncated.
var c = a + b  // c == 0
// Compiles ok, higher overflowed bits are truncated.
var d = a << b // d == 254

// Results are untyped constants.
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // overflows int
const R = 'a' + 0x7FFFFFFF          // overflows rune
// The above two lines both compile ok, though the
// two untyped value X and R both overflow their
// respective default types.

// Operation results or conversion results are
// typed values. These lines all fail to compile.
var e = X // error: untyped constant X overflows int
var h = R // error: constant 2147483744 overflows rune
const Y = 128 - int8(1)  // error: 128 overflows int8
const Z = uint8(255) + 1 // error: 256 overflow uint8
</code></pre>

<p>
</p>

</div>

<h4>About the results of arithmetic operator operations</h4>

<div>

Except bitwise shift operations, the result of a binary arithmetic operator operation
<ul>
<li>
	is a typed value of the same type of the two operands
	if the two operands are both typed values of the same type.
</li>
<li>
	is a typed value of the same type of the typed operand
	if only one of the two operands is a typed value.
	In the computation, the other (untyped) value will be deduced
	as a value of the type of the typed operand.
	In other words, the untyped operand will be implicitly
	converted to the type of the typed operand.
</li>
<li>
	is still an untyped value if both of the two operands are untyped.
	The default type of the result value is one of the two default
	types and it is the one appears latter in this list: <code>int</code>,
	<code>rune</code>, <code>float64</code>, <code>complex128</code>.
	For example, if the default type of one untyped operand is <code>int</code>,
	and the other one is <code>rune</code>, then the default type of
	the result untyped value is <code>rune</code>.
</li>
</ul>

The rules for the result of a bitwise shift operator operation
is a little complicated. Firstly, the result value is always an integer value.
Whether it is typed or untyped depends on specific scenarios.
<ul>
<li>
	If the left operand is a typed value (an integer value),
	then the type of the result is the same as the type of the left operand.
</li>
<li>
	If the left operand is an untyped value and the right operand is a constant,
	then the left operand will be always treated as an integer value,
	if its default type is not an integer type, it must be representable as an untyped integer
	and its default type will be viewed as <code>int</code>.
	For such cases, the result is also an untyped value and
	the default type of the result is the same as the left operand.
</li>
<li>
	If the left operand is an untyped value and the right operand
	is a non-constant integer, then the left operand will be first
	converted to the type it would assume if the bitwise shift operator
	operation were replaced by its left operand alone.
	The result is a typed value whose type is the assumed type.
</li>
</ul>

Example:
<pre class="line-numbers must-line-numbers"><code class="language-go">func main() {
	// Three untyped values. Their default
	// types are: int, rune(int32), complex64.
	const X, Y, Z = 2, 'A', 3i

	var a, b int = X, Y // two typed values.

	// The type of d is the default type of Y: rune.
	d := X + Y
	// The type of e is the type of a: int.
	e := Y - a
	// The type of f is the types of a and b: int.
	f := a * b
	// The type of g is Z's default type: complex64.
	g := Z * Y

	// Output: 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// Output: 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
</code></pre>

<p>
</p>

Another example (bitwise shift operations):
<pre class="line-numbers must-line-numbers"><code class="language-go">const N = 2
// A is an untyped value (default type as int).
const A = 3.0 << N // A == 12
// B is typed value (type is int8).
const B = int8(3.0) << N // B == 12

var m = uint(32)
// The following three lines are equivalent to
// each other. In the following two lines, the
// types of the two "1" are both deduced as
// int64, instead of int.
var x int64 = 1 << m
var y = int64(1 << m)
var z = int64(1) << m

// The following line fails to compile.
/*
var _ = 1.23 << m // error: shift of type float64
*/
</code></pre>

<p>
</p>

<a class="anchor" id="bitwise-shift-left-operand-type-deduction"></a>
<p>
The last rule for bitwise shift operator operation is to avoid the cases
that some bitwise shift operations return different results on different architectures
but the differences will not be detected in time.
For example, if the operand <code>1</code> is deduced as
<code>int</code> instead of <code>int64</code>,
the bitwise operation at line <i>13</i> (or line <i>12</i>) will
return different results between 32-bit architectures (<code>0</code>)
and 64-bit architectures (<code>0x100000000</code>),
which may produce some bugs hard to detect.
</p>

One interesting consequence of the last rule for bitwise shift operator operation
is shown in the following code snippet:

<pre class="line-numbers"><code class="language-go">const n = uint(2)
var m = uint(2)

// The following two lines compile okay.
var _ float64 = 1 << n
var _ = float64(1 << n)

// The following two lines fail to compile.
var _ float64 = 1 << m
var _ = float64(1 << m)
</code></pre>

The reason of the last two lines failing to compile is they are both
equivalent to the followings two line:

<pre class="line-numbers"><code class="language-go">var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
</code></pre>

<p>
</p>

Another example:

<pre class="line-numbers"><code class="language-go">package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
</code></pre>

The above program prints <code>2 0</code>, because the last two lines are equivalent to

<pre class="line-numbers"><code class="language-go">var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
</code></pre>

<p>
</p>
</div>

<h4>About integer division and remainder operations</h4>

<div>

<p>
Assume <code>x</code> and <code>y</code> are two operands of the same integer type,
the integer quotient <code>q</code> (<code>= x / y</code>)
and remainder <code>r</code> (<code>= x % y</code>)
satisfy <code>x == q*y + r</code>, where <code>|r| &lt; |y|</code>.
If <code>r</code> is not zero, its sign is the same as <code>x</code>
(the dividend).
The result of <code>x / y</code> is truncated towards zero.
</p>

<p>
If the divisor <code>y</code> is a constant, it must not be zero.
If the divisor is zero at run time and it is an integer,
a run-time panic occurs.
Panics are like exceptions in some other languages.
We can learn more about panics in <a href="control-flows-more.html">this article</a>.
</p>

Example:
<pre class="line-numbers"><code class="language-go">println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // compiles okay but panics at run time.

// The following two lines fail to compile.
println(1.0/0.0) // error: division by zero
println(0.0/0.0) // error: division by zero
</code></pre>

<p>
</p>

</div>

<h4>Using <code>op=</code> for binary arithmetic operators</h4>

<div>

<p>
For a binary arithmetic operator <code>op</code>, <code>x = x op y</code>
can be shortened to <code>x op= y</code>.
In the short form, <code>x</code> will be only evaluated once.
</p>

Example:
<pre class="line-numbers"><code class="language-go">var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
</code></pre>

</div>

<h4>The increment <code>++</code> and decrement <code>--</code> operators</h4>

<div>
<p>
Like many other popular languages, Go also supports
the increment <code>++</code> and decrement <code>--</code> operators.
However, operations using the two operators don't return any results,
so such operations can not be used as
<a href="expressions-and-statements.html">expressions</a>.
The only operand involved in such an operation must be a numeric value,
the numeric value must not be a constant, and the <code>++</code> or
<code>--</code> operator must follow the operand.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // ok. <=> a += 1 <=> a = a + 1
	b-- // ok. <=> b -= 1 <=> b = b - 1
	c++ // ok

	// The following lines fail to compile.
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
</code></pre>

</div>

<h3>String Concatenation Operator</h3>

<div>

As mentioned above, the addition operator can also be used as
string concatenation.

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Requirements for the Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			string concatenation
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			The two operands must be both values of the same string type.
		</td>
	</tr>
</tbody>
</table>

<p>
The <code>op=</code> form also applies for the string concatenation operator.
</p>

Example:
<pre class="line-numbers"><code class="language-go">println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
</code></pre>

<p>
</p>

<p>
If one of the two operands of a string concatenation operation
is a typed string, then the type of the result
string is the same as the type of the typed string.
If both of the two operands are untyped (constant) strings,
the result is also an untyped string value.
</p>

</div>

<h3>Boolean (a.k.a. Logical) Operators</h3>

<div>
<p>
Go supports two boolean binary operators and one boolean unary operator:
</p>

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Requirements for Operand(s)</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" class="text-center" style="vertical-align: middle; white-space: nowrap;" valign="middle" align="center">&amp;&amp;</th>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">
			boolean and (binary)<br/>
			a.k.a. conditional and
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2" valign="middle" align="left">
			The two operands must be both values of the same boolean type.
		</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="vertical-align: middle; white-space: nowrap;" valign="middle" align="center">||</th>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">
			boolean or (binary)<br/>
			a.k.a. conditional or
		</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="vertical-align: middle;white-space: nowrap;" valign="middle" align="center">!</th>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">
			boolean not (unary)
		</td>
		<td style="vertical-align: middle;" class="text-left" valign="middle" align="left">
			The type of the only operand must be a boolean type.
		</td>
	</tr>
</tbody>
</table>

<p>
We can use the <code>!=</code> operator introduced in the next sub-section as the <b>boolean xor</b> operator.
</p>

Mechanism explanations:
<pre class="disable-line-numbers111 fixed-width"><code class="language-go">// x    y       x && y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
</code></pre>

<p>
If one of the two operands is a typed boolean, then the type of the result
boolean is the same as the type of the typed boolean.
If both of the two operands are untyped booleans,
the result is also an untyped boolean value.
</p>

</div>

<h3>Comparison Operators</h3>

<div>
<p>
Go supports six comparison binary operators:
</p>

<table border="1" class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="white-space: nowrap;">Operator</th>
	<th class="text-center" valign="bottom" align="center">Name</th>
	<th class="text-center" valign="bottom" align="center">Requirements for the Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>==<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			equal to
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2" valign="middle" align="left">
			Generally, the types of its two operands must be the same.
			For detailed rules, please read <a href="value-conversions-assignments-and-comparisons.html#comparison-rules">comparison rules in Go</a>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" valign="middle" align="center"><div style="font-size:xx-small;"><br/></div>!=<div style="font-size:xx-small;"><br/></div></th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			not equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">&lt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			less than
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4" valign="middle" align="left">
			The two operands must be both values of the same integer type,
			floating-point type or string type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">&lt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			less than or equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">&gt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			larger than
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">&gt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" valign="middle" align="center">
			larger than or equal to
		</td>
	</tr>
</tbody>
</table>

<p>
The type of the result of any comparison operation is always an
untyped boolean value.
If both of the two operands of a comparison operation are constant,
the result is also a constant (boolean) value.
</p>

<p>
Later, if we say two values are comparable, we mean they can be compared
with the <code>==</code> and <code>!=</code> operators.
We will learn that values of which types are not comparable later.
Values of basic types are all comparable.
</p>

<p>
Please note that, not all real numbers can be accurately represented
in memory, so comparing two floating-point (or complex) values may
be not reliable. We should check whether or not the absolution of
the difference of two floating-point values is smaller than a small threshold
to judge whether or not the two floating-point values are equal.
</p>

</div>

<h3>Operator Precedence</h3>

<div>

<p>
The following is the operator precedence in Go.
Top ones have higher precedence.
The operators in the same line have the same precedence.
Like many other languages, <code>()</code> can be used to promote precedence.
</p>

<pre class="line-numbers fixed-width"><code class="language-go">*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
</code></pre>

<p>
</p>

<p>
One obvious difference to some other popular languages
is that the precedence of <code>&lt;&lt;</code> and
<code>&gt;&gt;</code> is higher than <code>+</code> and <code>-</code> in Go.
</p>

</div>

<a class="anchor" id="constant-expression-more"></a>
<h3>More About Constant Expressions</h3>

<div>

The following declared variable will be initialized as <code>2.2</code>
instead of <code>2.7</code>.
The reason is the precedence of the division operation is higher than
the addition operation, and in the division operation,
both <code>3</code> and <code>2</code> are viewed as integers.
The evaluation result of <code>3/2</code> is <code>1</code>.

<pre class="line-numbers"><code class="language-go">var x = 1.2 + 3/2
</code></pre>

<p>
</p>

The two named constants declared in the following program are not equal.
In the first declaration, both <code>3</code> and <code>2</code> are
viewed as integers, however, they are both viewed as floating-point numbers
in the second declaration.

<pre class="line-numbers"><code class="language-go">package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
	println(x) // +1.000000e-001
	println(y) // +1.500000e-001
}
</code></pre>

<p>
</p>

</div>

<h3>More Operators</h3>

<div>
<p>
Same as C/C++,
there are two pointer related operators, <code>*</code> and <code>&amp;</code>.
Yes the same operator symbols as the multiplication and bitwise-and operators.
<code>&amp;</code> is used to take the address of an addressable value,
and <code>*</code> is used to dereference a pointer value.
Unlike C/C++, in Go, values of pointer types don't support arithmetic operations.
For more details, please read <a href="pointer.html">pointers in Go</a> later.
</p>

<p>
There are some other operators in Go.
They will be introduced and explained in other Go 101 articles.
</p>

</div>
